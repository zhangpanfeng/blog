如图所示，如果有五个元素需要排序，那么需要排n-1趟，那么我们是不是可以写出一个循环出来，
for(int i = 1; i <= size-1; i++)但是我们发现每一趟的比较次数随着趟数的增大而减小，所以我们是不是可以
修改一下循环呢for(int i = size-1; i > 0; i--)这样不就成了随着趟数的增大i在减小吗，
现在我们算是写出了算法的框框了，我们还要比较元素，有图上分析可知，比较次数在逐趟减小
并且都是从下标为0开始比较的，于是，还需要一个循环来比较元素for(int j =0; j < ?; j++)
此时，问题来了，临界值是什么，“？”是几呢，再分析一下，第一趟比较下标从0到4，第二趟比较下标
从0到3发现小标的变化和i是一样的，并且可以等于i，于是修改循环for(int j =0; j <= i; j++),
此时感觉很对了，但是仔细想想，这个for循环的内容是什么呢，应该是source[j] 和source[j+1]
进行比较，然后交换，如果j可以等于i，那么j+1不就比i还大么，所以我们应该把等号去掉，
变为for(int j =0; j < i; j++)，为了使取名有意义，可以修改一下这两个循环
for(int outer = size - 1; outer > 0; outer--)
{
	for(int inner = 0; inner < outer; inner++)
	{
	    //比较逻辑
	    int temp = source[inner + 1];
        source[inner + 1] = array[inner];
        source[inner] = temp;
	}
}
